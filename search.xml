<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图_最短路径</title>
    <url>/2019/12/23/%E5%9B%BE-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>这篇文章以图的数组（邻接矩阵）储存表示，运用Dijkstra算法来求图中某节点到其他节点的最短路径</p>
<a id="more"></a>
<h2 id="图-邻接矩阵初始化"><a href="#图-邻接矩阵初始化" class="headerlink" title="图_邻接矩阵初始化"></a>图_邻接矩阵初始化</h2><h3 id="定义图-邻接矩阵存储"><a href="#定义图-邻接矩阵存储" class="headerlink" title="定义图_邻接矩阵存储"></a>定义图_邻接矩阵存储</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define MAX_NUM 20</span></span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">	char vexs[MAX_NUM];</span><br><span class="line">	int arcs[MAX_NUM][MAX_NUM];</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<h2 id="Prim算法求最小生成树"><a href="#Prim算法求最小生成树" class="headerlink" title="Prim算法求最小生成树"></a>Prim算法求最小生成树</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int LocateVex (MGraph G, char u)   //返回结点 U 的位置</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++)</span><br><span class="line">		<span class="keyword">if</span>(u == G.vexs[i])</span><br><span class="line">		<span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define INT_MAX 10000</span></span><br><span class="line">void ShortestPath_DJK(MGraph G,int u,string s[MAX_NUM],int *d)   //用Dijkstra算法求有向图G的V0顶点到其余顶点的最短路径s[v]及其带全长度d[v]</span><br><span class="line">&#123;</span><br><span class="line">	bool final[G.vexnum];       //fianl[v] = <span class="literal">true</span>,表示第v个节点的最短路径已经求得</span><br><span class="line">	</span><br><span class="line">	int v0 = LocateVex(G,u),v,w;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(v=0 ;v&lt;G.vexnum;v++)    //初始化</span><br><span class="line">	&#123;</span><br><span class="line">		final[v] = <span class="literal">false</span>;</span><br><span class="line">		d[v] = G.arcs[v0][v];</span><br><span class="line">		s[v] = <span class="string">'\n'</span>;</span><br><span class="line">		<span class="keyword">if</span>(d[v]&lt;INT_MAX)</span><br><span class="line">		&#123;</span><br><span class="line">			s[v].push_back(G.vexs[v0]);</span><br><span class="line">			s[v].push_back(G.vexs[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int i =1;i&lt;G.vexnum;i++)   //开始主循环，每次球的v0到某个v顶点的最短路径</span><br><span class="line">	&#123;</span><br><span class="line">		int min = INT_MAX;</span><br><span class="line">		<span class="keyword">for</span>(w = 0;w&lt;G.vexnum;w++)  //求出当前距离v0最近的节点</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!final[w] &amp;&amp; min&gt;d[w])</span><br><span class="line">			&#123;</span><br><span class="line">				v = w;</span><br><span class="line">				min = d[w];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		final[v] = <span class="literal">true</span>;   </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(w=0;w&lt;G.vexnum;w++)  // 更新当前最短路径及权值</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!final[w] &amp;&amp; ( (min+G.arcs[v][w])&lt;d[w] ) )</span><br><span class="line">			&#123;</span><br><span class="line">				d[w] = min+G.arcs[v][w];</span><br><span class="line">				<span class="keyword">for</span>(int j=0;j&lt;G.vexnum;j++)</span><br><span class="line">				s[w] = s[v];</span><br><span class="line">				s[w].push_back(G.vexs[w]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;G.vexnum;i++)   //输出所有的最短路径及权值</span><br><span class="line">	&#123;</span><br><span class="line">		int j=0;</span><br><span class="line">		<span class="keyword">if</span>(d[i] == INT_MAX)</span><br><span class="line">		cout&lt;&lt;G.vexs[v0]&lt;&lt;<span class="string">"---"</span>&lt;&lt;G.vexs[i]&lt;&lt;<span class="string">"无最短路径"</span>&lt;&lt;endl; </span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;s[i]&lt;&lt;<span class="string">"  最短路径长度为："</span>&lt;&lt;d[i]&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>最短路径</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome to My blog !</title>
    <url>/2019/12/22/hello-world/</url>
    <content><![CDATA[<p>欢迎参观我的WBCell（white blood cell）博客，可通过菜单中标签、分类、搜索等功能进行查找自己想要的内容。由于此博客才刚刚搭建，里面文章不多，网站功能也待完善。但是WBCell会不断学习，丰富博客内容并持续更新，后面会在网站中加入评论功能，方便大家学习交流。若发现文章中有错误或者可以改进的地方欢迎指出。</p>
<a id="more"></a>




<h3 id="联系作者"><a href="#联系作者" class="headerlink" title="联系作者"></a>联系作者</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">请留言QQ：1833551519@qq.com</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io" target="_blank" rel="noopener">hexo</a></p>
]]></content>
  </entry>
  <entry>
    <title>图_最小生成树</title>
    <url>/2019/12/22/%E5%9B%BE_%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>这篇文章以图的数组（邻接矩阵）储存表示，运用Prim算法来求图的最小生成树</p>
<a id="more"></a>

<h2 id="图-邻接矩阵初始化"><a href="#图-邻接矩阵初始化" class="headerlink" title="图_邻接矩阵初始化"></a>图_邻接矩阵初始化</h2><h3 id="定义图-邻接矩阵存储"><a href="#定义图-邻接矩阵存储" class="headerlink" title="定义图_邻接矩阵存储"></a>定义图_邻接矩阵存储</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">	char vexs[MAX_NUM];</span><br><span class="line">	int arcs[MAX_NUM][MAX_NUM];</span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
<h2 id="Prim算法求最小生成树"><a href="#Prim算法求最小生成树" class="headerlink" title="Prim算法求最小生成树"></a>Prim算法求最小生成树</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># define MAX_NUM 20</span></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	char adjvex;</span><br><span class="line">	int  lowcost;</span><br><span class="line">&#125;Closedge;            //记录从顶点集 U 到 V-U 的代价最小的边的辅助数组定义</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int LocateVex (MGraph G, char u)   //返回结点 U 的位置</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++)</span><br><span class="line">		<span class="keyword">if</span>(u == G.vexs[i])</span><br><span class="line">		<span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int minimun (Closedge closedge[],MGraph G)  //返回辅助数组记录最小值的下标</span><br><span class="line">&#123;</span><br><span class="line">	int min = INT_MAX,j=INT_MAX;</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++)</span><br><span class="line">		<span class="keyword">if</span>(min&gt;closedge[i].lowcost &amp;&amp; closedge[i].lowcost!=0)</span><br><span class="line">		&#123;</span><br><span class="line">			min = closedge[i].lowcost;</span><br><span class="line">			j=i;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void MiniSpan_Prim (MGraph G, char u)</span><br><span class="line">&#123;</span><br><span class="line">	Closedge closedge[MAX_NUM];</span><br><span class="line">	int k;</span><br><span class="line">	k = LocateVex (G,u);</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++)         //初始化辅助数组</span><br><span class="line">		<span class="keyword">if</span>(i!=k)</span><br><span class="line">			closedge[i] = &#123;u , G.arcs[k][i]&#125;;</span><br><span class="line">	closedge[k].lowcost = 0;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;G.vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		k = minimun(closedge,G);</span><br><span class="line">		cout&lt;&lt;closedge[k].adjvex&lt;&lt;<span class="string">"---"</span>&lt;&lt;G.vexs[k]&lt;&lt;endl;   //输出生成树的边</span><br><span class="line">		closedge[k].lowcost = 0;                      //第 K 个顶点并入 U 集</span><br><span class="line">		<span class="keyword">for</span>(int j=0;j&lt;G.vexnum;j++)         //重新选择最小边</span><br><span class="line">			<span class="keyword">if</span>(G.arcs[k][j]&lt;closedge[j].lowcost)</span><br><span class="line">				closedge[j] = &#123;G.vexs[k], G.arcs[k][j]&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>最小生成树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>图_十字链表</title>
    <url>/2019/12/22/%E5%9B%BE_%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>这篇文章包含了有向图十字链表的定义以及创建，也包含了邻接表的深度优先遍历、广度优先遍历，十字链表是基于邻接表的一种存储图的一种结构，其方法和邻接表大同小异</p>
<a id="more"></a>

<h2 id="十字链表表初始化"><a href="#十字链表表初始化" class="headerlink" title="十字链表表初始化"></a>十字链表表初始化</h2><h3 id="定义十字链表"><a href="#定义十字链表" class="headerlink" title="定义十字链表"></a>定义十字链表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct ArcBox &#123;</span><br><span class="line">	int tailvex,headvex;</span><br><span class="line">	struct ArcBox *hiink,*tlink;</span><br><span class="line">	int *info;</span><br><span class="line">&#125;;</span><br><span class="line">struct VexNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">	ArcBox *firstin,*firstout;</span><br><span class="line">&#125;;</span><br><span class="line">struct OLGraph&#123;</span><br><span class="line">	VexNode xlist[MAX_VERTEX_NUM];</span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表的创建"><a href="#邻接表的创建" class="headerlink" title="邻接表的创建"></a>邻接表的创建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int LocatVex(OLGraph &amp;g,int v)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;g.vexnum;i++)</span><br><span class="line">		<span class="keyword">if</span>(g.xlist[i].data==v)</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">void CreateDG(OLGraph &amp;g)</span><br><span class="line">&#123;</span><br><span class="line">	int v1,v2,i,j,IncInfo;</span><br><span class="line">	ArcBox *p;</span><br><span class="line">	cin&gt;&gt;g.vexnum&gt;&gt;g.arcnum&gt;&gt;IncInfo;  //IncInfo为零则各顶点不包含其他信息</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;g.vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;g.xlist[i].data;</span><br><span class="line">		g.xlist[i].firstin = NULL;</span><br><span class="line">		g.xlist[i].firstout = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(int k=0;k&lt;g.arcnum;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">		i = LocatVex(g,v1);</span><br><span class="line">		j = LocatVex(g,v2);</span><br><span class="line">		p = new ArcBox;</span><br><span class="line">		*p = &#123; i, j, g.xlist[j].firstin, g.xlist[i].firstout, NULL&#125;;</span><br><span class="line">		g.xlist[j].firstin = g.xlist[i].firstout = p;</span><br><span class="line">		<span class="keyword">if</span>(IncInfo) cin&gt;&gt;*p-&gt;info;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bool visited[100];</span><br><span class="line">void DFS (OLGraph &amp;g,int &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	cout&lt;&lt;g.xlist[v].data;</span><br><span class="line">	ArcBox *p = g.xlist[v].firstout;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[p-&gt;headvex])</span><br><span class="line">			DFS(g,p-&gt;headvex);</span><br><span class="line">		p = p-&gt;tlink; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFSTraverse(OLGraph &amp;g)</span><br><span class="line">&#123;</span><br><span class="line">	int v;</span><br><span class="line">	<span class="keyword">for</span>(v=0;v&lt;g.vexnum;v++) </span><br><span class="line">		visited[v] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(v=0;v&lt;g.vexnum;v++) </span><br><span class="line">		<span class="keyword">if</span>(!visited[v])</span><br><span class="line">			DFS(g,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void BFSTraverse(OLGraph &amp;g)</span><br><span class="line">&#123;</span><br><span class="line">	int v=0,HeadQueue,headnum;</span><br><span class="line">	std::queue&lt;int&gt; q;</span><br><span class="line">	ArcBox *BFStemp;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;g.vexnum;i++)</span><br><span class="line">	visited[i]=<span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;g.vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[i])</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;g.xlist[i].data;</span><br><span class="line">			q.push(g.xlist[i].data);</span><br><span class="line">			<span class="keyword">while</span> (!q.empty()) </span><br><span class="line">			&#123;</span><br><span class="line">				HeadQueue = q.front();</span><br><span class="line">				q.pop();                               //出队</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (int j = 0; j &lt; g.vexnum; j++) </span><br><span class="line">				&#123;</span><br><span class="line">                    <span class="keyword">if</span> (g.xlist[j].data == HeadQueue)</span><br><span class="line">                        headnum = j;                   //获取队头位置</span><br><span class="line">                &#125;</span><br><span class="line">                BFStemp = g.xlist[headnum].firstout;                    //用BFStemp来存储该节点的第一个出去的弧</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (BFStemp) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[BFStemp-&gt;headvex]) &#123;</span><br><span class="line">                        visited[BFStemp-&gt;headvex] = <span class="literal">true</span>;             //把结点都标记为真</span><br><span class="line">                        cout&lt;&lt;g.xlist[BFStemp-&gt;headvex].data; //访问元素</span><br><span class="line">                        q.push(g.xlist[BFStemp-&gt;headvex].data);     //把访问的元素都入队</span><br><span class="line">                    &#125;</span><br><span class="line">                    BFStemp = BFStemp-&gt;tlink;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>图_十字链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图_十字链表</tag>
      </tags>
  </entry>
  <entry>
    <title>图_邻接表</title>
    <url>/2019/12/22/%E5%9B%BE_%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
    <content><![CDATA[<p>这篇文章包含了有向图邻接表的定义以及创建，也包含了邻接表的深度优先遍历、广度优先遍历</p>
<a id="more"></a>

<h2 id="邻接表初始化"><a href="#邻接表初始化" class="headerlink" title="邻接表初始化"></a>邻接表初始化</h2><h3 id="定义邻接表"><a href="#定义邻接表" class="headerlink" title="定义邻接表"></a>定义邻接表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct ArcNode &#123;</span><br><span class="line">	int adjvex;</span><br><span class="line">	struct ArcNode* nextarc;</span><br><span class="line">	int *info;</span><br><span class="line">&#125;;</span><br><span class="line">struct VNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">	ArcNode *firstarc;</span><br><span class="line">&#125;;</span><br><span class="line">struct ALGraph&#123;</span><br><span class="line">	VNode AdjList[MAX_VERTEX_NUM];</span><br><span class="line">	int vexnum,arcnum;</span><br><span class="line">	int kind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="邻接表的创建"><a href="#邻接表的创建" class="headerlink" title="邻接表的创建"></a>邻接表的创建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">int LocatVex(ALGraph &amp;g,int v)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;g.vexnum;i++)</span><br><span class="line">		<span class="keyword">if</span>(g.AdjList[i].data==v)</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">void CreateALGraph(ALGraph &amp;g)</span><br><span class="line">&#123;</span><br><span class="line">	int vexnum,arcnum,v1,v2,j,k;</span><br><span class="line">	cin&gt;&gt;vexnum&gt;&gt;arcnum;</span><br><span class="line">	g.vexnum = vexnum;</span><br><span class="line">	g.arcnum = arcnum;</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;vexnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;g.AdjList[i].data;      </span><br><span class="line">		g.AdjList[i].firstarc = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;arcnum;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ArcNode *p;</span><br><span class="line">		p = new ArcNode;</span><br><span class="line">		cin&gt;&gt;v1&gt;&gt;v2;    		//输入弧两端顶点信息 </span><br><span class="line">		j = LocatVex(g,v1);</span><br><span class="line">		k = LocatVex(g,v2);</span><br><span class="line">		p-&gt;adjvex = k;</span><br><span class="line">		p-&gt;nextarc = g.AdjList[j].firstarc;</span><br><span class="line">		g.AdjList[j].firstarc = p;        //若要建立无向图重复以上三行代码将j，k互换即可</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历算法"><a href="#遍历算法" class="headerlink" title="遍历算法"></a>遍历算法</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bool visited[100];</span><br><span class="line">void DFS (ALGraph &amp;g,int &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">	visited[v] = <span class="literal">true</span>;</span><br><span class="line">	cout&lt;&lt;g.AdjList[v].data;</span><br><span class="line">	ArcNode *p = g.AdjList[v].firstarc;</span><br><span class="line">	<span class="keyword">while</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[p-&gt;adjvex])</span><br><span class="line">			DFS(g,p-&gt;adjvex);</span><br><span class="line">		p = p-&gt;nextarc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFSTraverse(ALGraph &amp;g)</span><br><span class="line">&#123;</span><br><span class="line">	int v;</span><br><span class="line">	<span class="keyword">for</span>(v=0;v&lt;g.vexnum;v++)</span><br><span class="line">		visited[v] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(v=0;v&lt;g.vexnum;v++)</span><br><span class="line">		<span class="keyword">if</span>(!visited[v])</span><br><span class="line">			DFS(g,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void BFSTraverse(ALGraph &amp;g)</span><br><span class="line">&#123;</span><br><span class="line">	int v=0,HeadQueue,headnum;</span><br><span class="line">	std::queue&lt;int&gt; q;</span><br><span class="line">	ArcNode *BFStemp;</span><br><span class="line">	<span class="keyword">for</span>(int i=0;i&lt;g.vexnum;i++)</span><br><span class="line">		visited[i] = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(v;v&lt;g.vexnum;v++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!visited[v])</span><br><span class="line">		&#123;</span><br><span class="line">			visited[v] = <span class="literal">true</span>;</span><br><span class="line">			cout&lt;&lt;g.AdjList[v].data;</span><br><span class="line">			q.push(g.AdjList[v].data);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(!q.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				HeadQueue = q.front();</span><br><span class="line">				q.pop();</span><br><span class="line">				<span class="keyword">for</span>(int i=0;i&lt;g.arcnum;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(g.AdjList[i].data == HeadQueue)</span><br><span class="line">						headnum = i;</span><br><span class="line">				&#125;</span><br><span class="line">				BFStemp = g.AdjList[headnum].firstarc;</span><br><span class="line">				<span class="keyword">while</span>(BFStemp)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(!visited[BFStemp-&gt;adjvex])</span><br><span class="line">					&#123;</span><br><span class="line">						visited[BFStemp-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line">						cout&lt;&lt;g.AdjList[BFStemp-&gt;adjvex].data;</span><br><span class="line">						q.push(g.AdjList[BFStemp-&gt;adjvex].data);</span><br><span class="line">					&#125;</span><br><span class="line">					BFStemp = BFStemp-&gt;nextarc;</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>图_邻接表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图_邻接表</tag>
      </tags>
  </entry>
  <entry>
    <title>树的存储</title>
    <url>/2019/12/22/%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>这篇文章包含了简单树的多种存储方式，以及哈夫曼树和求哈夫曼编码的算法</p>
<a id="more"></a>
<h2 id="简单树的存储方式"><a href="#简单树的存储方式" class="headerlink" title="简单树的存储方式"></a>简单树的存储方式</h2><h3 id="定义树的双亲表存储方式"><a href="#定义树的双亲表存储方式" class="headerlink" title="定义树的双亲表存储方式"></a>定义树的双亲表存储方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct PTNode&#123;  //节点结构</span><br><span class="line">  TElemType data;</span><br><span class="line">  int parent;         //双亲的位置域</span><br><span class="line">&#125;PTNode;</span><br><span class="line">typedef struct &#123;       //树结构</span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">  int r,n;          //根的位置和节点数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义树的孩子链表存储方式"><a href="#定义树的孩子链表存储方式" class="headerlink" title="定义树的孩子链表存储方式"></a>定义树的孩子链表存储方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct CTNode &#123;     //孩子节点</span><br><span class="line">  int  child;</span><br><span class="line">  struct CTNode *next;</span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line">typedef struct &#123;</span><br><span class="line">  TElemType data;</span><br><span class="line">  childPtr firstchild;  //孩子链表头指针</span><br><span class="line">&#125;CTBox;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">  int n,r;              //节点数和根的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义树的孩子兄弟表示法"><a href="#定义树的孩子兄弟表示法" class="headerlink" title="定义树的孩子兄弟表示法"></a>定义树的孩子兄弟表示法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct CSNode &#123;</span><br><span class="line">  ElemPype data;</span><br><span class="line">  struct CSNode *firstchild, *nextchild;</span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="哈夫曼树的存储结构"><a href="#哈夫曼树的存储结构" class="headerlink" title="哈夫曼树的存储结构"></a>哈夫曼树的存储结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  unsigned int weight;</span><br><span class="line">  unsigned int parent,lchild,rchild;</span><br><span class="line"></span><br><span class="line">&#125;HTNode, *HuffmanTree;        //动态分配数组存储哈夫曼树</span><br><span class="line">typedef char * * HuffmanCode; //动态分配数组存储哈夫曼编码表</span><br></pre></td></tr></table></figure>
<h3 id="求哈夫曼编码的算法"><a href="#求哈夫曼编码的算法" class="headerlink" title="求哈夫曼编码的算法"></a>求哈夫曼编码的算法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Selet(HuffmanTree &amp;HT,int n,int *s1,int *s2)//在[1,i-1]选择parent=0且weight最小的两个节点，序号为s1，s2 </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(HT[i].parent == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			*s1 = i; <span class="built_in">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(HT[i].parent == 0)</span><br><span class="line">			<span class="keyword">if</span>(HT[*s1].weight&gt;HT[i].weight)</span><br><span class="line">				*s1 = i;</span><br><span class="line"></span><br><span class="line">	HT[*s1].parent = n+1;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(HT[i].parent == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			*s2 = i; <span class="built_in">break</span>;</span><br><span class="line">		&#125;	</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(HT[i].parent == 0)</span><br><span class="line">			<span class="keyword">if</span>(HT[*s2].weight&gt;HT[i].weight)</span><br><span class="line">				*s2 = i;</span><br><span class="line"></span><br><span class="line">		HT[*s2].parent = n+1;		</span><br><span class="line">&#125;</span><br><span class="line">void HuffmanCoding (HuffmanTree &amp;HT,HuffmanCode &amp;HC,int *w,int n)   //w存放n个字符的权值，构造哈夫曼树HT，求出哈夫曼编码HC</span><br><span class="line">&#123;</span><br><span class="line">  int i=1,m = n*2 - 1;  //总结点数</span><br><span class="line">  HuffmanTree p;</span><br><span class="line">  HT = (HuffmanTree)malloc((m+1)*sizeof(HTNode));  //0号单元未应用 </span><br><span class="line">  <span class="keyword">for</span>(p = HT,i;i&lt;=n;i++)</span><br><span class="line">  	*(++p) = &#123;w[i-1],0,0,0&#125;;</span><br><span class="line">  <span class="keyword">for</span>(i;i&lt;=m;i++) </span><br><span class="line">  	*(++p) = &#123;0,0,0,0&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=n+1;i&lt;=m;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	int s1,s2;</span><br><span class="line">  	Selet(HT,i-1,&amp;s1,&amp;s2);            </span><br><span class="line">	HT[i].lchild = s1;</span><br><span class="line">	HT[i].rchild = s2;</span><br><span class="line">	HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //---从叶子节点到根逆向求每个字符的哈夫曼编码</span><br><span class="line">  HC = (HuffmanCode)malloc((n+1)*sizeof(char*));</span><br><span class="line">  </span><br><span class="line">  int f,c,j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	string s;</span><br><span class="line">  	<span class="keyword">for</span>(c = i ,f=HT[i].parent ; f!=0 ; c=f,f=HT[f].parent )</span><br><span class="line">  		<span class="keyword">if</span>(HT[f].lchild == c)</span><br><span class="line">  			s.insert(0,<span class="string">"0"</span>);</span><br><span class="line">  		<span class="keyword">else</span></span><br><span class="line">  			s.insert(0,<span class="string">"1"</span>);</span><br><span class="line">  </span><br><span class="line">  	HC[i] = (char *)malloc((s.length()+1)*sizeof(char));</span><br><span class="line">  	<span class="keyword">for</span>(j=0;j&lt;s.length();j++)</span><br><span class="line">  		HC[i][j] = s[j];</span><br><span class="line">  	HC[i][j] = <span class="string">'\n'</span>;</span><br><span class="line">  	</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  cout&lt;&lt;<span class="string">"number		weight		HuffmanCode"</span>&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	cout&lt;&lt;i&lt;&lt;<span class="string">"		"</span>&lt;&lt;HT[i].weight&lt;&lt;<span class="string">"		"</span>;</span><br><span class="line">  	<span class="keyword">for</span>(int j=0;HC[i][j]!=<span class="string">'\n'</span>;j++)</span><br><span class="line">  	cout&lt;&lt;HC[i][j];</span><br><span class="line">  	cout&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>树</category>
        <category>哈夫曼树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title>简单二叉树</title>
    <url>/2019/12/22/%E7%AE%80%E5%8D%95%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>这篇文章包含了简单二叉树的定义以及创建，也包含了二叉树的先序、中序、后序遍历的递归算法，还包含了使用队列对二叉树层序遍历的非递归算法</p>
<a id="more"></a>

<h2 id="简单二叉树初始化"><a href="#简单二叉树初始化" class="headerlink" title="简单二叉树初始化"></a>简单二叉树初始化</h2><h3 id="定义二叉树链式存储"><a href="#定义二叉树链式存储" class="headerlink" title="定义二叉树链式存储"></a>定义二叉树链式存储</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">struct Bitree&#123;</span><br><span class="line">	char data;</span><br><span class="line">	struct Bitree *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line">typedef Bitree *tree;</span><br></pre></td></tr></table></figure>
<h3 id="先序创建二叉树"><a href="#先序创建二叉树" class="headerlink" title="先序创建二叉树"></a>先序创建二叉树</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void CreateBitree (tree &amp;t)  </span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	ch = getchar();</span><br><span class="line">	<span class="keyword">if</span>(ch==<span class="string">' '</span>)</span><br><span class="line">		t = NULL;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		t = new Bitree; </span><br><span class="line">		t-&gt;data = ch;</span><br><span class="line">		CreateBitree(t-&gt;lchild);</span><br><span class="line">		CreateBitree(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void PreOrderTraverse (tree &amp;t)   </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(t)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;t-&gt;data;</span><br><span class="line">		PreOrderTraverse(t-&gt;lchild);</span><br><span class="line">		PreOrderTraverse(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void InOrderTraverse (tree &amp;t)  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(t)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrderTraverse(t-&gt;lchild);</span><br><span class="line">		cout&lt;&lt;t-&gt;data;</span><br><span class="line">		InOrderTraverse(t-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void PostOrderTraverse (tree &amp;t)   </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(t)</span><br><span class="line">	&#123;</span><br><span class="line">		PostOrderTraverse(t-&gt;lchild);</span><br><span class="line">		PostOrderTraverse(t-&gt;rchild);</span><br><span class="line">		cout&lt;&lt;t-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h2><h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void InOrderTraverse(tree &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">	std::stack&lt;tree&gt; s;</span><br><span class="line">	tree p=t;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!s.empty()||p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(p) </span><br><span class="line">		&#123;	</span><br><span class="line">			s.push(p);</span><br><span class="line">			p=p-&gt;lchild;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">if</span>(!s.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			p=s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">			cout&lt;&lt;p-&gt;data;</span><br><span class="line">			p=p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; 		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void LevelOrderTraverse (tree &amp;t)  </span><br><span class="line">&#123;</span><br><span class="line">	std::queue&lt;tree&gt; q;</span><br><span class="line">    tree front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == NULL)<span class="built_in">return</span>;</span><br><span class="line"></span><br><span class="line">    q.push(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        front = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (front-&gt;lchild)</span><br><span class="line">            q.push(front-&gt;lchild);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (front-&gt;rchild)</span><br><span class="line">            q.push(front-&gt;rchild);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;front-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
